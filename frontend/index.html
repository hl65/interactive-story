<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>äº’åŠ¨å°è¯´æ¸¸æˆ</title>
  <link rel="stylesheet" href="styles/main.css">
</head>
<body>
  <h1>äº’åŠ¨å°è¯´æ¸¸æˆ</h1>

  <!-- ç« èŠ‚è¾“å…¥åŒºåŸŸ -->
  <div id="chapterSection" class="section active">
    <h2>è¯·è¾“å…¥å°è¯´ç« èŠ‚å†…å®¹</h2>
    <div>
      <label for="storySelect">é€‰æ‹©å·²æœ‰æ•…äº‹ï¼š</label>
      <select id="storySelect">
        <option value="">-- è¯·é€‰æ‹©æ•…äº‹ --</option>
      </select>
    </div>
    <textarea id="chapterText" rows="10" cols="80" placeholder="æ•…äº‹å†…å®¹å°†æ˜¾ç¤ºåœ¨è¿™é‡Œï¼Œæ‚¨ä¹Ÿå¯ä»¥ç›´æ¥è¾“å…¥æ–°æ•…äº‹"></textarea><br>
    <button id="startGameBtn">å¼€å§‹æ¸¸æˆ</button>
  </div>

  <!-- è§’è‰²é€‰æ‹©åŒºåŸŸ -->
  <div id="characterSection" class="section">
    <h2>è¯·é€‰æ‹©ä½ çš„è§’è‰²</h2>
    <div id="characterList"></div>
    <button id="selectCharacterBtn">ç¡®å®šé€‰æ‹©</button>
  </div>

  <!-- å…³å¡æ¸¸æˆåŒºåŸŸ -->
  <div id="gameSection" class="section">
    <h2 id="levelTitle"></h2>
    <p id="levelDescription"></p>
    <div id="imageContainer">
      <img id="levelImage" src="" alt="èƒŒæ™¯å›¾ç‰‡">
      <!-- åŠ è½½åŠ¨ç”»é®ç½© -->
      <div id="imageSpinner">
         <span>åŠ è½½ä¸­...</span>
      </div>
    </div><br>
    <p><strong>AI (<span id="aiRole"></span>)ï¼š</strong> <span id="aiDialogue">åŠ è½½ä¸­...</span></p>
    <audio id="responseAudio"></audio>

    <h3>è¯·è¾“å…¥ä½ çš„å›åº”</h3>
    <div class="response-container">
      <button id="startVoiceBtn" title="å¼€å§‹è¯­éŸ³è¾“å…¥">ğŸ¤</button>
      <input type="text" id="userResponse" disabled>
      <button id="submitResponseBtn" disabled>
        <span class="button-text">æäº¤å›åº”</span>
        <span class="loading-spinner">è¯„ä¼°ä¸­...</span>
      </button>
    </div>

    <p id="evaluationFeedback"></p>

    <!-- æ·»åŠ æç¤ºåŒºåŸŸ -->
    <div class="hints-section">
        <div class="hints-header" onclick="toggleHints()">
            <h3>ğŸ’¡ å…³å¡æç¤º</h3>
            <span class="toggle-icon">â–¼</span>
        </div>
        <div id="hintsContent" class="hints-content">
            <!-- æç¤ºå†…å®¹å°†é€šè¿‡ JavaScript åŠ¨æ€æ·»åŠ  -->
        </div>
    </div>
  </div>

  <!-- èŠå¤©è®°å½•åŒºåŸŸ -->
  <div id="chatHistorySection" class="section">
    <h2>èŠå¤©è®°å½•</h2>
    <div id="chatHistory" class="chat"></div>
  </div>

  <!-- è°ƒè¯•æ—¥å¿—åŒºåŸŸ -->
  <div id="debugPanel" class="section">
    <h2>
      è°ƒè¯•æ—¥å¿—
      <div class="controls">
        <button class="debug-toggle" id="toggleDebug">_</button>
      </div>
    </h2>
    <pre id="debugOutput"></pre>
    <div class="resize-handle right"></div>
    <div class="resize-handle bottom"></div>
    <div class="resize-handle bottom-right"></div>
  </div>

  <script>
    let sessionId = null;
    let selectedCharacterIndex = null;

    // å¯åŠ¨ SSE è°ƒè¯•æ—¥å¿—æµï¼Œå°†æ¥æ”¶åˆ°çš„è°ƒè¯•æ—¥å¿—æ˜¾ç¤ºåœ¨ debugOutput åŒºåŸŸ
    const eventSource = new EventSource("/debug_stream");

    // è®¾ç½®ä¸€ä¸ªå…¨å±€å˜é‡ï¼Œç”¨äºä¿å­˜å½“å‰æ´»è·ƒçš„è¯·æ±‚æ—¥å¿—å—
    let currentLogBlock = null;

    // æ·»åŠ è°ƒè¯•é¢æ¿æ§åˆ¶åŠŸèƒ½
    document.getElementById('toggleDebug').addEventListener('click', function() {
      const debugPanel = document.getElementById('debugPanel');
      const isMinimized = debugPanel.classList.toggle('minimized');
      this.textContent = isMinimized ? 'â–¡' : '_';
    });

    // ä¿®æ”¹è°ƒè¯•æ—¥å¿—å¤„ç†å‡½æ•°
    eventSource.onmessage = function(event) {
      const debugOutput = document.getElementById("debugOutput");
      try {
        const logData = JSON.parse(event.data);
        const logEntry = document.createElement("div");
        
        const now = new Date();
        const timestamp = now.toLocaleTimeString('zh-CN', { 
          hour12: false,
          hour: '2-digit',
          minute: '2-digit',
          second: '2-digit',
          fractionalSecondDigits: 3
        });
        
        // ä¼˜åŒ–æ—¥å¿—æ˜¾ç¤ºæ ¼å¼
        let logContent = "";
        if (logData.type === "intermediate" || logData.type === "answer") {
          const lastLog = debugOutput.lastElementChild;
          if (lastLog && lastLog.getAttribute("data-type") === logData.type) {
            debugOutput.removeChild(lastLog);
          }
          logContent = `${logData.type === "intermediate" ? "æ¨ç†" : "å›ç­”"}: ${logData.log}`;
        } else {
          logContent = logData.log;
        }
        
        logEntry.innerHTML = `<span style="color: #888">[${timestamp}]</span> ${logContent}`;
        logEntry.setAttribute("data-type", logData.type);
        
        debugOutput.appendChild(logEntry);
        debugOutput.scrollTop = debugOutput.scrollHeight;

        // é™åˆ¶æ—¥å¿—æ•°é‡ï¼Œä¿æŒæ€§èƒ½
        while (debugOutput.children.length > 100) {
          debugOutput.removeChild(debugOutput.firstChild);
        }
      } catch (e) {
        console.error("Error parsing debug log:", e);
      }
    };

    // é¡µé¢åŠ è½½æ—¶è·å–æ•…äº‹åˆ—è¡¨å¹¶å¡«å……ä¸‹æ‹‰èœå•
    async function loadStoryList() {
      try {
        const response = await fetch("/list_stories");
        const stories = await response.json();
        const select = document.getElementById("storySelect");
        select.innerHTML = '<option value="">-- è¯·é€‰æ‹©æ•…äº‹ --</option>';
        
        stories.forEach((story, index) => {
          const option = document.createElement("option");
          option.value = story.id;
          option.textContent = `${story.title} - ${story.author} (${story.generated ? "å·²ç”Ÿæˆ" : "æœªç”Ÿæˆ"}) | ${story.excerpt}`;
          select.appendChild(option);
        });
      } catch (err) {
        console.error("åŠ è½½å·²æœ‰æ•…äº‹å¤±è´¥", err);
      }
    }
    
    // é¡µé¢åŠ è½½æ—¶åˆå§‹åŒ–æ•…äº‹åˆ—è¡¨
    window.addEventListener("load", loadStoryList);
    
    // å½“é€‰æ‹©æ•…äº‹æ—¶æ›´æ–°æ–‡æœ¬æ¡†å†…å®¹
    document.getElementById("storySelect").addEventListener("change", async function() {
      const selectedId = this.value;
      if (!selectedId) {
        document.getElementById("chapterText").value = "";
        return;
      }
      
      try {
        const response = await fetch("/list_stories");
        const stories = await response.json();
        const selectedStory = stories.find(s => s.id === Number(selectedId));
        if (selectedStory) {
          document.getElementById("chapterText").value = selectedStory.content;
        }
      } catch (err) {
        console.error("åŠ è½½æ•…äº‹å¤±è´¥", err);
      }
    });

    // æ·»åŠ æ˜¾ç¤º/éšè—sectionçš„å‡½æ•°
    function showSection(sectionId) {
        document.querySelectorAll('.section').forEach(section => {
            section.classList.remove('active');
        });
        document.getElementById(sectionId).classList.add('active');
    }

    document.getElementById("startGameBtn").addEventListener("click", async () => {
      const chapterText = document.getElementById("chapterText").value.trim();
      if (!chapterText) {
        alert("è¯·è¾“å…¥ç« èŠ‚å†…å®¹ï¼");
        return;
      }
      const res = await fetch("/create_game", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ chapter_text: chapterText })
      });
      const data = await res.json();
      if (data.error) {
        alert(data.error);
        return;
      }
      sessionId = data.session_id;
      // æ˜¾ç¤ºå‰§æƒ…æ¦‚è¿°å›¾ç‰‡åŠè§’è‰²åˆ—è¡¨
      showSection('characterSection');
      displayCharacters(data.characters);
      updateChat(`ç³»ç»Ÿï¼š${data.message}`);
    });

    function displayCharacters(characters) {
      const listDiv = document.getElementById("characterList");
      listDiv.innerHTML = "";
      characters.forEach((char, index) => {
        const radio = document.createElement("input");
        radio.type = "radio";
        radio.name = "character";
        radio.value = index;
        if (index === 0) radio.checked = true;
        const label = document.createElement("label");
        label.innerText = `${char.name} - ${char.description}`;
        const br = document.createElement("br");
        listDiv.appendChild(radio);
        listDiv.appendChild(label);
        listDiv.appendChild(br);
      });
    }

    document.getElementById("selectCharacterBtn").addEventListener("click", async () => {
      const radios = document.getElementsByName("character");
      let index = 0;
      for (const radio of radios) {
        if (radio.checked) {
          index = parseInt(radio.value);
          break;
        }
      }
      const res = await fetch("/select_character", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ session_id: sessionId, character_index: index })
      });
      const data = await res.json();
      if (data.error) {
        alert(data.error);
        return;
      }
      updateChat(`ç³»ç»Ÿï¼š${data.message}`);
      showSection('gameSection');
      loadLevel();
    });

    async function loadLevel() {
      const levelImage = document.getElementById("levelImage");
      const imageSpinner = document.getElementById("imageSpinner");
      const aiDialogueElem = document.getElementById("aiDialogue");
      
      // ç¡®ä¿æ˜¾ç¤ºåŠ è½½åŠ¨ç”»
      imageSpinner.style.display = "flex";
      levelImage.style.display = "none";
      
      try {
          const res = await fetch("/get_level", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ session_id: sessionId })
          });
          const data = await res.json();
          
          // æ›´æ–°å…³å¡ä¿¡æ¯
          document.getElementById("levelTitle").innerText = "å…³å¡ " + data.level_number;
          document.getElementById("levelDescription").innerText = data.description;
          document.getElementById("aiRole").innerText = data.ai_role;
  
          // å¤„ç†å›¾ç‰‡URL
          let imgUrl = "";
          if (typeof data.level_image === "string") {
              imgUrl = data.level_image;
          } else if (typeof data.level_image === "object" && data.level_image.url) {
              imgUrl = data.level_image.url;
          }
  
          // å¦‚æœå·²ç»æœ‰æœ‰æ•ˆçš„å›¾ç‰‡URL
          if (imgUrl.startsWith("http")) {
              await loadImageWithRetry(imgUrl);
          } else {
              // å¼€å§‹è½®è¯¢ç­‰å¾…å›¾ç‰‡ç”Ÿæˆ
              pollForImage(sessionId);
          }
  
          // æ¸…ç©º AI å¯¹è¯åŒºåŸŸï¼Œéšåé€šè¿‡æµå¼æ¥å£å®æ—¶æ›´æ–°
          aiDialogueElem.innerText = "";
          // å¯åŠ¨ EventSource ç›‘å¬æµå¼ AI å¯¹è¯
          const dialogueSource = new EventSource("/stream_level_dialogue?session_id=" + sessionId);
          let currentAIResponse = "";  // ç”¨äºç´¯ç§¯å½“å‰çš„ AI å›åº”
          let isFirstToken = true;  // ç”¨äºæ ‡è®°æ˜¯å¦æ˜¯ç¬¬ä¸€ä¸ª token
          dialogueSource.onmessage = function(event) {
            // ç¬¬ä¸€ä¸ª token æ—¶æ¸…ç©º AI å¯¹è¯åŒºåŸŸ
            if (isFirstToken) {
              aiDialogueElem.innerText = "";
              isFirstToken = false;
            }
            // event.data è¿”å›å½“å‰ token
            aiDialogueElem.innerText += event.data;
            currentAIResponse += event.data;
          };
  
          dialogueSource.onerror = async function(err) {
            console.error("Dialogue stream error:", err);
            dialogueSource.close();
            // å½“å¯¹è¯å®Œæˆæ—¶
            if (currentAIResponse.trim()) {
              // æ›´æ–°èŠå¤©è®°å½•
              updateChat(`AI (${data.ai_role}): ${currentAIResponse}`);
              try {
                await fetch("/update_chat_history", {
                  method: "POST",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify({ 
                    session_id: sessionId, 
                    message: `AI (${data.ai_role}): ${currentAIResponse}`
                  })
                });
  
                // è½¬æ¢æ–‡æœ¬ä¸ºè¯­éŸ³å¹¶æ’­æ”¾
                const ttsResponse = await fetch("/text_to_speech", {
                  method: "POST",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify({ text: currentAIResponse })
                });
                
                if (ttsResponse.ok) {
                  const audioUrl = await ttsResponse.text();
                  console.log("æ”¶åˆ°çš„éŸ³é¢‘æ•°æ®:", audioUrl.substring(0, 100) + "..."); // æ‰“å°å‰100ä¸ªå­—ç¬¦
  
                  if (audioUrl && audioUrl !== "è¯­éŸ³è¾“å‡ºå¤±è´¥") {
                      const audio = document.getElementById("responseAudio");
                      audio.src = audioUrl;
                      try {
                          // ç¡®ä¿éŸ³é¢‘å…ƒç´ å·²ç»åŠ è½½
                          audio.load();
                          // æ·»åŠ åŠ è½½å®Œæˆäº‹ä»¶ç›‘å¬å™¨
                          audio.oncanplay = async () => {
                              try {
                                  console.log("éŸ³é¢‘å·²åŠ è½½ï¼Œå¼€å§‹æ’­æ”¾");
                                  await audio.play();
                                  console.log("éŸ³é¢‘å¼€å§‹æ’­æ”¾");
                              } catch (playError) {
                                  console.error("æ’­æ”¾éŸ³é¢‘å¤±è´¥:", playError);
                              }
                          };
                          audio.onerror = (e) => {
                              console.error("éŸ³é¢‘åŠ è½½å¤±è´¥:", e);
                          };
                      } catch (playError) {
                          console.error("æ’­æ”¾éŸ³é¢‘å¤±è´¥:", playError);
                      }
                  } else {
                      console.error("æ— æ•ˆçš„éŸ³é¢‘æ•°æ®:", audioUrl);
                  }
                }
              } catch (error) {
                console.error("å¤„ç† AI å“åº”æ—¶å‡ºé”™:", error);
              }
            }
          };
  
          // å¯ç”¨è¾“å…¥æ¡†å’Œæäº¤æŒ‰é’®
          document.getElementById("userResponse").disabled = false;
          document.getElementById("submitResponseBtn").disabled = false;

          // æ·»åŠ æç¤ºå†…å®¹
          const hintsContent = document.getElementById('hintsContent');
          hintsContent.innerHTML = ''; // æ¸…ç©ºç°æœ‰æç¤º
          if (data.hints && data.hints.length > 0) {
              data.hints.forEach(hint => {
                  const hintDiv = document.createElement('div');
                  hintDiv.className = 'hint-item';
                  hintDiv.textContent = hint;
                  hintsContent.appendChild(hintDiv);
              });
          } else {
              const noHintDiv = document.createElement('div');
              noHintDiv.className = 'hint-item';
              noHintDiv.textContent = 'å½“å‰å…³å¡æš‚æ— æç¤º...';
              hintsContent.appendChild(noHintDiv);
          }
      } catch (err) {
          console.error("åŠ è½½å…³å¡å¤±è´¥:", err);
          imageSpinner.style.display = "none";
          levelImage.src = "https://placehold.co/600x400?text=Load+Failed";
          levelImage.style.display = "block";
      }
  }
  
  // æ–°å¢ï¼šå¸¦é‡è¯•çš„å›¾ç‰‡åŠ è½½å‡½æ•°
  async function loadImageWithRetry(imgUrl, maxRetries = 3) {
    const levelImage = document.getElementById("levelImage");
    const imageSpinner = document.getElementById("imageSpinner");
    
    for (let i = 0; i < maxRetries; i++) {
        try {
            await new Promise((resolve, reject) => {
                const timeoutId = setTimeout(() => {
                    reject(new Error("Image load timeout"));
                }, 10000); // 10ç§’è¶…æ—¶
                
                levelImage.onload = () => {
                    clearTimeout(timeoutId);
                    imageSpinner.style.display = "none";
                    levelImage.style.display = "block";
                    resolve();
                };
                
                levelImage.onerror = () => {
                    clearTimeout(timeoutId);
                    reject(new Error(`Failed to load image: ${imgUrl}`));
                };
                
                levelImage.src = imgUrl;
            });
            return;
        } catch (err) {
            console.error(`å›¾ç‰‡åŠ è½½å¤±è´¥ï¼Œå°è¯• ${i + 1}/${maxRetries}:`, err);
            if (i < maxRetries - 1) {
                await new Promise(resolve => setTimeout(resolve, 2000));
            }
        }
    }
    
    console.error("å›¾ç‰‡åŠ è½½å¤±è´¥ï¼Œä½¿ç”¨å ä½å›¾");
    levelImage.src = "https://placehold.co/600x400?text=Load+Failed";
    imageSpinner.style.display = "none";
    levelImage.style.display = "block";
}

  async function pollForImage(sessionId, maxAttempts = 10) {
      const levelImage = document.getElementById("levelImage");
      const imageSpinner = document.getElementById("imageSpinner");
      let attempts = 0;
      
      const pollInterval = setInterval(async () => {
          attempts++;
          if (attempts > maxAttempts) {
              clearInterval(pollInterval);
              imageSpinner.style.display = "none";
              levelImage.src = "https://placehold.co/600x400?text=Generation+Timeout";
              levelImage.style.display = "block";
              return;
          }
          
          try {
              const res = await fetch("/get_level", {
                  method: "POST",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify({ session_id: sessionId })
              });
              const data = await res.json();
              
              let imgUrl = "";
              if (typeof data.level_image === "string") {
                  imgUrl = data.level_image;
              } else if (typeof data.level_image === "object" && data.level_image.url) {
                  imgUrl = data.level_image.url;
              }
              
              if (imgUrl.startsWith("http")) {
                  clearInterval(pollInterval);
                  await loadImageWithRetry(imgUrl);
              }
          } catch (err) {
              console.error("è½®è¯¢å›¾ç‰‡å¤±è´¥:", err);
          }
      }, 3000); // æ¯3ç§’è½®è¯¢ä¸€æ¬¡
  }

    async function submitResponse() {
      const userResponse = document.getElementById("userResponse").value.trim();
      if (!userResponse) {
        alert("è¯·è¾“å…¥ä½ çš„å›åº”ï¼");
        return;
      }
      
      // ç¦ç”¨è¾“å…¥æ¡†å’ŒæŒ‰é’®ï¼Œæ˜¾ç¤ºåŠ è½½åŠ¨ç”»
      const submitBtn = document.getElementById("submitResponseBtn");
      const userInput = document.getElementById("userResponse");
      const buttonText = submitBtn.querySelector(".button-text");
      const loadingSpinner = submitBtn.querySelector(".loading-spinner");
      
      submitBtn.disabled = true;
      userInput.disabled = true;
      buttonText.style.display = "none";
      loadingSpinner.style.display = "inline";
      
      try {
        const res = await fetch("/submit_response", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ session_id: sessionId, user_response: userResponse })
        });
        const data = await res.json();
        
        // æ·»åŠ ç”¨æˆ·å›åº”å’Œç³»ç»Ÿè¯„ä»·åˆ°èŠå¤©å†å²
        updateChat(`ç”¨æˆ·ï¼š${userResponse}`);
        updateChat(`ç³»ç»Ÿè¯„ä»·ï¼š${data.evaluation_feedback}`);
        
        document.getElementById("evaluationFeedback").innerText = data.message;
        document.getElementById("userResponse").value = "";
        const aiDialogueElem = document.getElementById("aiDialogue");
        aiDialogueElem.innerText = "";  // æ¸…ç©ºå½“å‰çš„ AI å¯¹è¯
        
        if (data.passed) {
          // å»¶æ—¶åŠ è½½ä¸‹ä¸€å…³å¡
          setTimeout(loadLevel, 1500);
        } else {
          // å¦‚æœæœªé€šè¿‡ï¼Œé‡æ–°è·å– AI å¯¹è¯
          aiDialogueElem.innerText = "åŠ è½½ä¸­...";
          
          // å¯åŠ¨æ–°çš„ EventSource è·å–æµå¼å¯¹è¯
          const dialogueSource = new EventSource("/stream_level_dialogue?session_id=" + sessionId);
          let currentAIResponse = "";
          let isFirstToken = true;
          dialogueSource.onmessage = function(event) {
            if (isFirstToken) {
              aiDialogueElem.innerText = "";
              isFirstToken = false;
            }
            aiDialogueElem.innerText += event.data;
            currentAIResponse += event.data;
          };
          
          dialogueSource.onerror = async function(err) {
            console.error("Dialogue stream error:", err);
            dialogueSource.close();
            if (currentAIResponse.trim()) {
              updateChat(`AI (${document.getElementById("aiRole").innerText}): ${currentAIResponse}`);
              try {
                await fetch("/update_chat_history", {
                  method: "POST",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify({ 
                    session_id: sessionId, 
                    message: `AI (${document.getElementById("aiRole").innerText}): ${currentAIResponse}`
                  })
                });

                // è½¬æ¢æ–‡æœ¬ä¸ºè¯­éŸ³å¹¶æ’­æ”¾
                const ttsResponse = await fetch("/text_to_speech", {
                  method: "POST",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify({ text: currentAIResponse })
                });
                
                if (ttsResponse.ok) {
                  const audioUrl = await ttsResponse.text();
                  console.log("æ”¶åˆ°çš„éŸ³é¢‘æ•°æ®:", audioUrl.substring(0, 100) + "..."); // æ‰“å°å‰100ä¸ªå­—ç¬¦

                  if (audioUrl && audioUrl !== "è¯­éŸ³è¾“å‡ºå¤±è´¥") {
                      const audio = document.getElementById("responseAudio");
                      audio.src = audioUrl;
                      try {
                          // ç¡®ä¿éŸ³é¢‘å…ƒç´ å·²ç»åŠ è½½
                          audio.load();
                          // æ·»åŠ åŠ è½½å®Œæˆäº‹ä»¶ç›‘å¬å™¨
                          audio.oncanplay = async () => {
                              try {
                                  console.log("éŸ³é¢‘å·²åŠ è½½ï¼Œå¼€å§‹æ’­æ”¾");
                                  await audio.play();
                                  console.log("éŸ³é¢‘å¼€å§‹æ’­æ”¾");
                              } catch (playError) {
                                  console.error("æ’­æ”¾éŸ³é¢‘å¤±è´¥:", playError);
                              }
                          };
                          audio.onerror = (e) => {
                              console.error("éŸ³é¢‘åŠ è½½å¤±è´¥:", e);
                          };
                      } catch (playError) {
                          console.error("æ’­æ”¾éŸ³é¢‘å¤±è´¥:", playError);
                      }
                  } else {
                      console.error("æ— æ•ˆçš„éŸ³é¢‘æ•°æ®:", audioUrl);
                  }
                }
              } catch (error) {
                console.error("å¤„ç† AI å“åº”æ—¶å‡ºé”™:", error);
              }
            }
            submitBtn.disabled = false;
            userInput.disabled = false;
          };
        }
      } catch (error) {
        console.error("æäº¤å›åº”å¤±è´¥:", error);
        alert("æäº¤å›åº”å¤±è´¥ï¼Œè¯·é‡è¯•");
      } finally {
        // æ¢å¤æŒ‰é’®å’Œè¾“å…¥æ¡†çŠ¶æ€
        submitBtn.disabled = false;
        userInput.disabled = false;
        buttonText.style.display = "inline";
        loadingSpinner.style.display = "none";
        // ç¡®ä¿æŒ‰é’®æ–‡æœ¬è¢«æ­£ç¡®è¿˜åŸ
        buttonText.textContent = "æäº¤å›åº”";
      }
    }

    // ç‚¹å‡»æäº¤æŒ‰é’®æ—¶æäº¤å›åº”
    document.getElementById("submitResponseBtn").addEventListener("click", submitResponse);
    
    // åœ¨è¾“å…¥æ¡†ä¸­æŒ‰å›è½¦é”®æ—¶æäº¤å›åº”
    document.getElementById("userResponse").addEventListener("keypress", (event) => {
      if (event.key === "Enter" && !event.shiftKey) {
        event.preventDefault();
        submitResponse();
      }
    });

    // æ›¿æ¢åŸæœ‰çš„è¯­éŸ³æ§åˆ¶ç›¸å…³ä»£ç 
    let mediaRecorder = null;
    let audioChunks = [];

    document.getElementById("startVoiceBtn").addEventListener("click", async function() {
        const button = this;
        
        // å¦‚æœæ­£åœ¨å½•éŸ³ï¼Œåˆ™åœæ­¢å½•éŸ³
        if (mediaRecorder && mediaRecorder.state === "recording") {
            mediaRecorder.stop();
            button.classList.remove("recording");
            button.title = "å¼€å§‹è¯­éŸ³è¾“å…¥";
            return;
        }
        
        try {
            const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
            audioChunks = [];
            mediaRecorder = new MediaRecorder(stream);
            
            mediaRecorder.addEventListener("dataavailable", event => {
                audioChunks.push(event.data);
            });

            mediaRecorder.addEventListener("stop", async () => {
                // åœæ­¢æ‰€æœ‰éŸ³è½¨
                stream.getTracks().forEach(track => track.stop());
                
                const audioBlob = new Blob(audioChunks);
                const formData = new FormData();
                formData.append("file", audioBlob, "audio.wav");
                
                try {
                    const response = await fetch("/transcribe_audio", {
                        method: "POST",
                        body: formData
                    });
                    
                    if (response.ok) {
                        const text = await response.text();
                        document.getElementById("userResponse").value = text;
                    }
                } catch (err) {
                    console.error("è½¬å†™å¤±è´¥:", err);
                    alert("è¯­éŸ³è½¬å†™å¤±è´¥");
                }
            });

            mediaRecorder.start();
            button.classList.add("recording");
            button.title = "ç‚¹å‡»åœæ­¢å½•éŸ³";
            
        } catch (err) {
            console.error("è¯­éŸ³è¾“å…¥å¤±è´¥:", err);
            alert("æ— æ³•è®¿é—®éº¦å…‹é£");
        }
    });

    function updateChat(message) {
      const chatDiv = document.getElementById("chatHistory");
      // ä½¿ç”¨ pre æ ‡ç­¾ä¿æŒæ ¼å¼ï¼Œå¹¶æ·»åŠ æ ·å¼
      const messageElem = document.createElement("pre");
      messageElem.style.margin = "5px 0";
      messageElem.style.whiteSpace = "pre-wrap";
      messageElem.style.wordWrap = "break-word";
      messageElem.textContent = message;
      chatDiv.appendChild(messageElem);
      chatDiv.scrollTop = chatDiv.scrollHeight;
    }

    // æ·»åŠ è°ƒè¯•é¢æ¿æ‹–åŠ¨åŠŸèƒ½
    const debugPanel = document.getElementById('debugPanel');
    const debugTitle = debugPanel.querySelector('h2');
    let isDragging = false;
    let isResizing = false;
    let currentX;
    let currentY;
    let initialX;
    let initialY;
    let xOffset = 0;
    let yOffset = 0;
    let initialWidth;
    let initialHeight;
    let resizeDirection = '';

    // åˆå§‹åŒ–é¢æ¿ä½ç½®
    debugPanel.style.top = '20px';
    debugPanel.style.left = '20px';

    // åˆå§‹åŒ–æ‹–åŠ¨åŠŸèƒ½
    function initDragAndResize() {
        // æ‹–åŠ¨å¼€å§‹
        function dragStart(e) {
            if (debugPanel.classList.contains('minimized')) return;
            
            const target = e.target;
            
            // æ£€æŸ¥æ˜¯å¦ç‚¹å‡»äº†è°ƒæ•´å¤§å°çš„æŠŠæ‰‹
            if (target.classList.contains('resize-handle')) {
                isResizing = true;
                initialWidth = debugPanel.offsetWidth;
                initialHeight = debugPanel.offsetHeight;
                resizeDirection = target.classList.contains('right') ? 'right' : 
                                target.classList.contains('bottom') ? 'bottom' : 'both';
            }
            // åªæœ‰ç‚¹å‡»æ ‡é¢˜æ æ‰èƒ½ç§»åŠ¨
            else if (target === debugTitle || target.parentElement === debugTitle) {
                isDragging = true;
            }
            
            if (e.type === "touchstart") {
                initialX = e.touches[0].clientX - xOffset;
                initialY = e.touches[0].clientY - yOffset;
            } else {
                initialX = e.clientX - xOffset;
                initialY = e.clientY - yOffset;
            }
        }

        // æ‹–åŠ¨/è°ƒæ•´å¤§å°ç»“æŸ
        function dragEnd() {
            isDragging = false;
            isResizing = false;
        }

        // å¤„ç†ç§»åŠ¨å’Œè°ƒæ•´å¤§å°
        function drag(e) {
            if (debugPanel.classList.contains('minimized')) return;
            
            let clientX, clientY;
            if (e.type === "touchmove") {
                clientX = e.touches[0].clientX;
                clientY = e.touches[0].clientY;
            } else {
                clientX = e.clientX;
                clientY = e.clientY;
            }

            if (isDragging) {
                e.preventDefault();
                currentX = clientX - initialX;
                currentY = clientY - initialY;
                xOffset = currentX;
                yOffset = currentY;

                // ç¡®ä¿é¢æ¿ä¸ä¼šè¢«æ‹–å‡ºè§†çª—
                const maxX = window.innerWidth - debugPanel.offsetWidth;
                const maxY = window.innerHeight - debugPanel.offsetHeight;
                currentX = Math.min(Math.max(currentX, 0), maxX);
                currentY = Math.min(Math.max(currentY, 0), maxY);

                debugPanel.style.transform = `translate(${currentX}px, ${currentY}px)`;
            }
            else if (isResizing) {
                e.preventDefault();
                const dx = clientX - initialX;
                const dy = clientY - initialY;
                
                // æ ¹æ®è°ƒæ•´æ–¹å‘è®¾ç½®æ–°çš„å°ºå¯¸
                if (resizeDirection === 'right' || resizeDirection === 'both') {
                    const newWidth = Math.max(300, initialWidth + dx);
                    debugPanel.style.width = `${newWidth}px`;
                }
                if (resizeDirection === 'bottom' || resizeDirection === 'both') {
                    const newHeight = Math.max(200, initialHeight + dy);
                    debugPanel.style.height = `${newHeight}px`;
                }
            }
        }

        // æ·»åŠ äº‹ä»¶ç›‘å¬å™¨
        debugPanel.addEventListener("mousedown", dragStart);
        document.addEventListener("mousemove", drag);
        document.addEventListener("mouseup", dragEnd);
        debugPanel.addEventListener("touchstart", dragStart);
        document.addEventListener("touchmove", drag);
        document.addEventListener("touchend", dragEnd);
    }

    // åˆå§‹åŒ–è°ƒè¯•é¢æ¿
    initDragAndResize();
    debugPanel.style.transform = 'translate(20px, 20px)';
    debugPanel.style.display = 'block';
    debugPanel.classList.remove('section');
    debugPanel.style.width = '500px';
    debugPanel.style.height = '300px';

    // ä¿®æ”¹æœ€å°åŒ–æŒ‰é’®å¤„ç†å‡½æ•°
    document.getElementById('toggleDebug').addEventListener('click', function(e) {
        e.stopPropagation(); // é˜²æ­¢è§¦å‘æ‹–åŠ¨
        
        const isMinimized = debugPanel.classList.toggle('minimized');
        this.textContent = isMinimized ? 'â–¡' : '_';
        
        // æœ€å°åŒ–çŠ¶æ€ç®¡ç†
        if (isMinimized) {
            debugPanel.style.resize = 'none';
            isDragging = false; // å¼ºåˆ¶åœæ­¢ä»»ä½•æ­£åœ¨è¿›è¡Œçš„æ‹–åŠ¨
        } else {
            debugPanel.style.resize = 'both';
            debugPanel.style.height = '300px'; // æ¢å¤é»˜è®¤é«˜åº¦
        }
    });

    // åˆå§‹åŒ–è°ƒè¯•é¢æ¿
    debugPanel.style.transform = 'translate(20px, 20px)';  // åˆå§‹ä½ç½®
    debugPanel.style.display = 'block';  // ç¡®ä¿æ˜¾ç¤º
    debugPanel.classList.remove('section');  // ç§»é™¤å¯èƒ½å½±å“æ˜¾ç¤ºçš„ç±»
    
    // è®¾ç½®åˆå§‹å¤§å°
    debugPanel.style.width = '500px';
    debugPanel.style.height = '300px';

    // æ·»åŠ æç¤ºåˆ‡æ¢åŠŸèƒ½
    function toggleHints() {
        const hintsContent = document.getElementById('hintsContent');
        const toggleIcon = document.querySelector('.toggle-icon');
        hintsContent.classList.toggle('expanded');
        toggleIcon.textContent = hintsContent.classList.contains('expanded') ? 'â–¼' : 'â–¶';
    }
  </script>
</body>
</html>